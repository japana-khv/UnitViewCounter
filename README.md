# задание:

### Требования:
 с++14, консольное приложение, без сторонних библиотек, windows/linux x64

### Задание:
Нужно написать алгоритм, который для каждого юнита из массива определяет, сколько других юнитов попадает в его поле зрения.

Юнит представлен в виде:
```c++
struct unit
{
    vec2 position; // 2D позиция
    vec2 direction; // нормализованный вектор-направление
    float fov_deg = 0.0f; // угол зрения в градусах (0...180)
    float distance = 0.0f; // дальность видимости
};
```

Алгоритм нужно реализовать в виде функции:

```c++
void Task::checkVisible(const std::vector<unit> &input_units, std::vector<int> &result)
{
    // fill result vector 
}
```

На вход функция получает константный вектор юнитов (где 1 <= input_units.size <= 10^5), и вектор целых числел который нужно заполнить. 


### Example:
in_units
```
{{1.0, 1.0}, {0.707106, 0.707106}, 60.0, 10.0},
{{3.0, 3.0}, {-0.707106, -0.707106}, 60.0, 10.0},
{{2.0, 2.0}, {1.0, 0.0}, 30.0, 10.0},
{{10.0, 10.0}, {-0.707106, -0.707106}, 10.0, 13.0}
```
results:
```
2, 2, 0, 3
```

### Решение:
Решение выполнено с применением immintrin.h двумя способами.

* **Первый.** Плоскость делится на сетку квадратных ячеек 8 x 8 . Юниты распределяются по ячейкам. Для каждого юнита производися поиск видимых ячеек сетки. А затем производится подсчет видимых юнитов в каждой из видимых ячеек сетки. Поиск видимых ячеек сетки производится обходом дерева. Вершина дерева - ячейка размером 8x8. Дочерние элементы вершины - 4 ячейки размером 4x4 и т.д. 
* **Второй**. Для каждого юнита производится проверка видимости каждого юнита. Сложность алгоритма N^2

Результаты обоих способов сравниваются между собой и выводится результат сравнения.

Оба решения используют предварительно вычисленные векторы секторов поля зрения. 

